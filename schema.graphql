type Player @entity {
    id: ID! # 0x prefixed hex string
    initTimestamp: Int!
    homeWorld: Planet # allows null because 0x0000000000000000000000000000000000000000 has no homeWorld
    planets: [Planet!]! @derivedFrom(field: "owner")
}

type Planet @entity {
    id: ID! # locationid 0x prefixed hex string
    locationDec: BigInt! # loc decimal version of locationid
    owner: Player!
    isInitialized: Boolean!
    createdAt: Int!
    lastUpdated: Int!
    perlin: Int!
    range: Int!
    speed: Int!
    defense: Int!
    population: Int!
    populationCap: Int!
    populationGrowth: Int!
    silverCap: Int!
    silverGrowth: Int!
    silver: Int!
    planetLevel: Int!
    upgradeState0: Int!
    upgradeState1: Int!
    upgradeState2: Int!
    hatLevel: Int!
    planetResource: PlanetResource!
    spaceType: SpaceType!
    silverSpentComputed: Int! # Computed cost of applied upgrades
}

type ArrivalsAtInterval @entity  {
    id: ID!
    arrivals: [Arrival!]!
}

type Meta @entity  {
    id: ID!
    lastProcessed: Int! # the last block timestamp the block handler processed arrivals for
}

type Arrival @entity {
    id: ID!
    arrivalId: Int! # same as id, but sortable because its an int
    player: Player!
    fromPlanetDec: BigInt! # cant be mapped as a planet because possibly wont be created until processed
    toPlanetDec: BigInt! # cant be mapped as a planet because possibly wont be created until processed
    popArriving: Int!
    silverMoved: Int!
    departureTime: Int!
    arrivalTime: Int!
    receivedAt: Int!
    processedAt: Int
}

type Hat @entity {
    id: ID!
    planet: Planet! # same as id, but sortable because its an int
    player: Player!
    hatLevel: Int
    timestamp: Int
}

type Upgrade @entity {
    id: ID!
    planet: Planet! # same as id, but sortable because its an int
    player: Player!
    timestamp: Int
}

enum PlanetResource {
    NONE
    SILVER
}

enum SpaceType {
    NEBULA
    SPACE
    DEEP_SPACE
}
